/*
用户进程通过read系统调用读取一个磁盘文件中的数据，若该文件的数据不在内存，
则该进程进入睡眠等待状态。请求read系统调用会导致CPU从用户态切换到核心态。

1.当读写锁是写加锁状态时，在这个锁被解锁之前，所有试图对这个锁加锁的线程都会被阻塞
2.当读写锁在读加锁状态时，所有试图以读模式对它进行加锁的线程都可以得到访问权，但是以写模式对它进行加锁的线程将会被阻塞
3.当读写锁在读模式的锁状态时，如果有另外的线程试图以写模式加锁，读写锁通常会阻塞随后的读模式锁的请求，这样可以避免读模式锁长期占用，而等待的写模式锁请求则长期阻塞。
读写锁在写加锁状态时，其他进行写操作线程会阻塞. 写锁就是防止其他进程读或写. 读锁就是防止在读的时候有写进程进入

在使用锁保证现场安全时可能会出现 活跃度 失败的情况主要包括 饥饿、丢失信号、和活锁、死锁 等。【多线程除了死锁之外遇到最多的就是活跃度问题了】

饥饿 ：指线程需要访问的资源 被永久拒绝 ，以至于不能再继续进行。解决饥饿问题需要平衡线程对资源的竞争，
如线程的优先级、任务的权重、执行的周期等。

活锁 ：指线程虽然没有被阻塞，但由于某种条件不满足，一直尝试重试却始终失败。解决活锁问题需要对
重试机制 引入一些随机性。例如如果检测到冲突，那么就暂停随机的一定时间进行重试，这会大大减少碰撞的可能性。

 */

public class Test {
    public static void main(String[] args) {
        long b = Long.parseLong("26");
        System.out.println(b);

        System.out.println(Long.toBinaryString(i));  //返回i的二进制的字符串表示
        System.out.println(Long.toOctalString(i));  //返回i的八进制的字符串表示
        System.out.println(Long.toHexString(i));  //返回i的十六进制的字符串表示
        System.out.println(Long.toString(i, 10));  //返回i的p进制的字符串表示
    }
}
